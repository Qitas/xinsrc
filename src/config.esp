bool ICACHE_FLASH_ATTR loadConfiguration()
{
	File configFile = SPIFFS.open("/config.json", "r");
	if (!configFile)
	{
#ifdef DEBUG
		Serial.println(F("[ 警告 ] 打开配置文件失败"));
#endif
		return false;
	}
	size_t size = configFile.size();
	std::unique_ptr<char[]> buf(new char[size]);
	configFile.readBytes(buf.get(), size);
	DynamicJsonBuffer jsonBuffer;
	JsonObject &json = jsonBuffer.parseObject(buf.get());
	if (!json.success())
	{
#ifdef DEBUG
		Serial.println(F("[ 警告 ] Failed to parse config file"));
#endif
		return false;
	}
#ifdef DEBUG
	Serial.println(F("[ 提醒 ] Config file found"));
	json.prettyPrintTo(Serial);
	Serial.println();
#endif

	JsonObject &network = json["network"];
	JsonObject &hardware = json["hardware"];
	JsonObject &general = json["general"];
	JsonObject &mqtt = json["mqtt"];
	JsonObject &ntp = json["ntp"];

	if (hardware.containsKey("wifipin"))
	{
		wifipin = hardware["wifipin"];
		if (wifipin!=255)
		{
			pinMode(wifipin, OUTPUT);
			digitalWrite(wifipin, LEDoff);
		}
	}
	if (hardware.containsKey("doorstatpin"))
	{
		doorstatpin = hardware["doorstatpin"];
		if (doorstatpin!=255)
		{
			pinMode(doorstatpin, INPUT);
		}
	}

	if (hardware.containsKey("openlockpin"))
	{
		openlockpin = hardware["openlockpin"];
		if (openlockpin != 255)
		{
			openLockButton = Bounce();
			openLockButton.attach(openlockpin, INPUT_PULLUP);
			openLockButton.interval(30);
		}
	}

#ifndef OFFICIALBOARD
	readertype = hardware["readertype"];
	if (readertype == 1 || readertype == 5)
	{
		int wgd0pin = hardware["wgd0pin"];
		int wgd1pin = hardware["wgd1pin"];
		setupWiegandReader(wgd0pin, wgd1pin); 		// also some other settings like weather to use keypad or not, LED pin, BUZZER pin, Wiegand 26/34 version
	}
	else if (readertype == 0 || readertype == 4)
	{
		int rfidss = 15;
		int rfidgain = 33;
		if (hardware.containsKey("sspin"))
		{
			rfidss = hardware["sspin"];
		}
		if (hardware.containsKey("rfidgain"))
		{
			rfidgain = hardware["rfidgain"];
		}	
		setupMFRC522Reader(rfidss, rfidgain);
	}
	else if (readertype == 2 || readertype == 6)
	{
		int  rfidss = hardware["sspin"];
		NRCReader(rfidss);
		//setupPN532Reader(rfidss);
	}
	#ifndef  NoRDM6300
	if (readertype>2) Serial.begin(9600);
	#endif
#endif

	autoRestartIntervalSeconds = general["restart"];
	wifiTimeout = network["offtime"];
	const char *bssidmac = network["bssid"];
	byte bssid[6];
	parseBytes(bssidmac, ':', bssid, 6, 16);
	deviceHostname = strdup(general["hostnm"]);
	WiFi.hostname(deviceHostname);
	if (!MDNS.begin(deviceHostname))
	{
		writeEvent("错误", "mDNS", "mDNS begin error", "");
		#ifdef DEBUG
		Serial.println("[ 错误 ]Error setting up MDNS responder!");
		#endif
	}
	MDNS.addService("http", "tcp", 80);
	const char *ntpserver = ntp["server"];
	int ntpinter = ntp["interval"];
	timeZone = ntp["timezone"];
	activateTime = hardware["rtime"];
	lockType = hardware["ltype"];
	relayType = hardware["rtype"];

#ifndef OFFICIALBOARD
	relayPin = hardware["rpin"];
	pinMode(relayPin, OUTPUT);
	digitalWrite(relayPin, !relayType);
#endif

	const char *ssid = network["ssid"];
	const char *password = network["pswd"];
	wmode = network["wmode"];
	http_pass = strdup(general["pswd"]);
	ws.setAuthentication("admin", http_pass);
	if (wmode == 1)
	{
		int hid = network["hide"];
#ifdef DEBUG
		Serial.println(F("[ 提醒 ] 设备AP模式"));
#endif
		const char *APssid;
		
		if (network.containsKey("ssid") && strlen(network["ssid"])>1)
		{
			APssid = network["ssid"];
		}
		else
		{
			uint8_t Addr[6];
			WiFi.softAPmacAddress(Addr);
			char ssid[15];
			sprintf(ssid, "RFID[%02x%02x%02x]", Addr[3], Addr[4], Addr[5]);
			APssid = ssid;
		}
		const char *apipch;
		if (network.containsKey("apip") && strlen(network["apip"])>1)
		{
			apipch = network["apip"];
		}
		else
		{
			apipch = "192.168.4.1";
		}
		const char *apsubnetch;
		if (network.containsKey("apsubnet"))
		{
			apsubnetch = network["apsubnet"];
		}
		else
		{
			apsubnetch = "255.255.255.0";
		}
		IPAddress apip;
		IPAddress apsubnet;
		apip.fromString(apipch);
		apsubnet.fromString(apsubnetch);
		return startAP(apip, apsubnet, hid, APssid, password);
	}
	else
	{
		if (network["dhcp"] == "0")
		{
			WiFi.mode(WIFI_STA);
			const char *clientipch = network["ip"];
			const char *subnetch = network["subnet"];
			const char *gatewaych = network["gateway"];
			const char *dnsch = network["dns"];
			IPAddress clientip;
			IPAddress subnet;
			IPAddress gateway;
			IPAddress dns;
			clientip.fromString(clientipch);
			subnet.fromString(subnetch);
			gateway.fromString(gatewaych);
			dns.fromString(dnsch);
			WiFi.config(clientip, gateway, subnet, dns);
		}
		if (!connectSTA(ssid, password, bssid))
		{
			return false;
		}
	}


	NTP.Ntp(ntpserver, timeZone, ntpinter * 60);

	IPAddress timeserverip;
	WiFi.hostByName(ntpserver, timeserverip);
	String ip = printIP(timeserverip);
	writeEvent("提醒", "NTP", "Connecting NTP Server", ip);
#ifdef DEBUG
	Serial.println("[ 提醒 ] Trying to setup NTP Server");
#endif


	mqttenabled = mqtt["enabled"];
	if (mqttenabled == 1)
	{
#ifdef DEBUG
		Serial.println("[ 提醒 ] Trying to setup MQTT");
#endif
		String mhsString = mqtt["host"];
		mhs = strdup(mhsString.c_str());

		mport = mqtt["port"];

		String muserString = mqtt["user"];
		muser = strdup(muserString.c_str());
		String mpasString = mqtt["pswd"];
		mpas = strdup(mpasString.c_str());
		String mqttTopicString = mqtt["topic"];
		mqttTopic = strdup(mqttTopicString.c_str());

		interval = mqtt["syncrate"];

		if (mqtt["mqttlog"]==1)
			mqttEvents = true;
		else
			mqttEvents = false;


		
		mqttClient.setServer(mhs, mport);
		mqttClient.setCredentials(muser, mpas);
		mqttClient.onDisconnect(onMqttDisconnect);
		mqttClient.onPublish(onMqttPublish);
		mqttClient.onSubscribe(onMqttSubscribe);
		mqttClient.onConnect(onMqttConnect);
		mqttClient.onMessage(onMqttMessage);
#ifdef DEBUG
		Serial.println("[ 提醒 ] try to call mqttconnect ");
#endif
		connectToMqtt();
	}
#ifdef DEBUG
	Serial.println(F("[ 提醒 ] Configuration done."));
	Serial.print(F("QRFID v"));
	Serial.println(VERSION);
#endif
	return true;
}
