
.. _at32f421:

AT32F421
===============

* 关键词：``Cortex-M4`` ``120MHz`` ``COMP`` ``sLib`` ``ERTC`` ``TSSOP20``
* 资源库：`GitHub <https://github.com/SoCXin/AT32F421>`_

.. contents::
    :local:

Xin简介
-----------

:ref:`arterytek` :ref:`cortex_m4` 单核 MCU，高达120MHz的CPU运算速度与内建数字信号处理器(DSP)，最高可支持64KB闪存存储器(Flash)及16KB随机存取存储器(SRAM)

片上集成了多达2个USART、2个SPI(可复用I²S)、2个I²C、1个16位高级定时器、5个16位通用定时器，和5通道DMA控制器。 同时还扩展了1个高速轨到轨输入/输出模拟电压比较器，1个采样率高达2M SPS的12位15通道高速ADC。

几乎所有I/O口可容忍5V输入信号，且所有I/O口均为快速I/O，具有多种可选功能还支持端口重映射，极佳的灵活性和易用性满足多种应用需求。

.. contents::
    :local:

规格参数
~~~~~~~~~~~

基本参数
^^^^^^^^^^^

* 内核频率：120 MHz
* 供电电压：2.4V - 3.6V
* 工作温度：-40°C - 105°C
* HBM:6 KV, CDM:1000 V

特征参数
^^^^^^^^^^^

* 15ch ADC (12bit 2MSPS)
* 2 x USART
* 2 x I2C + 2 x SPI/I2S
* ERTC (1ppm的分辨率)
* COMP (轨到轨比较器,1/4、1/2、3/4 VREF)
* sLib安全库 (Security Library)

.. note::
    :ref:`arterytek` 自行开发的 :ref:`arterytek_slib` 可支持密码保护指定范围程序区，方案商烧录核心算法到此区域，提供给下游客户做二次开发，强化了产品本身的安全性、可靠性和二次开发的使用便利度。

芯片架构
~~~~~~~~~~~

.. image:: images/AT32F421S.png
    :target: https://www.arterytek.com/cn/product/AT32F421.jsp#Resource

时钟体系
^^^^^^^^^^^^^

.. image:: images/AT32F421C.png
    :target: https://www.arterytek.com/cn/product/AT32F421.jsp#Resource

:ref:`at32f421` 系列产品包含最多1个高级定时器(16bit)、5个普通定时器(16bit)、1个基本定时器(16bit)、以及2个看门狗定时器、和1个系统滴答定时器。


Xin选择
-----------

通过对比不同品牌不同型号差异，明确具体选型和关注指标，评估替代性和兼容性

.. contents::
    :local:

.. hint::
    :ref:`at32f421` 定位超值产品，主要替代F030、F103、E230、F330等型号，相对对标产品而言拥有更高的制程工艺和性能。


品牌对比
~~~~~~~~~

.. list-table::
    :header-rows:  1

    * - Xin
      - DMIPS
      - RAM
      - FLASH
      - UART
      - ADC
      - TIM
      - COMP
    * - :ref:`at32f421`
      - 150
      - 8/16
      - 16/32/64
      - 2
      - 2MSPS
      - 5+1
      - 1
    * - :ref:`stm32f030`
      - 44
      - 32
      - 64/128/256
      - 2/3/5
      - 2.0B
      - 5+1
      - NO
    * - :ref:`stm32f103`
      - 90
      - 32
      - 64/128/256
      - 2/3/5
      - 2.0B
      - 5+1
      - NO
    * - GD32F330
      - 135
      - 4/8/16
      - 16/32/64/128
      - 2
      - 2.6MSPS
      - 5+1
      - 1
    * - GD32E230
      - 90
      - 4/8
      - 16/32/64
      - 2
      - 2.6MSPS
      - 5+1
      - 1

:ref:`at32f421` 系列与 :ref:`stm32f030` 系列管脚兼容

型号对比
~~~~~~~~~


.. list-table::
    :header-rows:  1

    * - Name
      - DMIPS
      - RAM
      - FLASH
      - UART
      - CAN2.0B
      - USB
      - SPIM
    * - :ref:`at32f421`
      - 150 (120MHz)
      - 8/16
      - 16/32/64
      - 2
      - NO
      - NO
      - NO
    * - AT32F425
      - 120 (96MHz)
      - 20
      - 32/64
      - 4
      - 1
      - OTG
      - NO
    * - :ref:`at32f415`
      - 175
      - 32
      - 64/128/256
      - 2/3/5
      - 1
      - OTG
      - NO
    * - :ref:`at32f413`
      - 250
      - 16/32/64
      - 64/128/256
      - 2/3/5
      - 2
      - D/H
      - 16M
    * - :ref:`at32f403`
      - 300
      - 16/32/64
      - 64/128/256
      - 2/3/5
      - 2
      - D/H
      - 16M

.. note::
    :ref:`arterytek` 目前只有 :ref:`cortex_m4` 单核的 MCU产品，均具备 :ref:`arterytek_slib` 功能，高性能系列才具备 :ref:`arterytek_spim` 功能

版本对比
~~~~~~~~~

.. image:: images/AT32F421.png
    :target: https://www.arterytek.com/cn/product/AT32F421.jsp#Resource

.. note::
    基于TSSOP20封装的 :ref:`cortex_m4` 120MHz主频的MCU规格实属少见。


Xin应用
-----------

.. contents::
    :local:

.. image:: images/B_AT32F421.jpg
    :target: https://item.taobao.com/item.htm?_u=ogas3eu93a4&id=632845784689

.. warning::
     :ref:`at32f421` 除了高主频并没有配置太多外设，存储资源少，只用于控制通信器件实现数据转发较合适

USART应用
~~~~~~~~~~~

中断收发数据
^^^^^^^^^^^^^

.. code-block:: bash

    /* ----------------- USART1 and USART2 configuration -------------------- */
    USART_StructInit(&USART_InitStructure);
    USART_InitStructure.USART_BaudRate = 9600;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

    /* Configure USART1 */
    USART_Init(USART1, &USART_InitStructure);
    /* Configure USART2 */
    USART_Init(USART2, &USART_InitStructure);

    /* Enable USART1 Receive and Transmit interrupts */
    USART_INTConfig(USART1, USART_INT_RDNE, ENABLE);
    USART_INTConfig(USART1, USART_INT_TDE, ENABLE);

    /* Enable USART2 Receive and Transmit interrupts */
    USART_INTConfig(USART2, USART_INT_RDNE, ENABLE);
    USART_INTConfig(USART2, USART_INT_TDE, ENABLE);

    /* Enable the USART1 */
    USART_Cmd(USART1, ENABLE);
    /* Enable the USART2 */
    USART_Cmd(USART2, ENABLE);

    ...

    void USART1_IRQHandler(void)
    {
        if(USART_GetITStatus(USART1, USART_INT_RDNE) != RESET)
        {
            /* Read one byte from the receive data register */
            RxBuffer1[RxCounter1++] = USART_ReceiveData(USART1);

            if(RxCounter1 == NbrOfDataToRead1)
            {
                /* Disable the USART1 Receive interrupt */
                USART_INTConfig(USART1, USART_INT_RDNE, DISABLE);
            }
        }
        if(USART_GetITStatus(USART1, USART_INT_TDE) != RESET)
        {
            /* Write one byte to the transmit data register */
            USART_SendData(USART1, TxBuffer1[TxCounter1++]);

            if(TxCounter1 == NbrOfDataToTransfer1)
            {
                /* Disable the USART1 Transmit interrupt */
                USART_INTConfig(USART1, USART_INT_TDE, DISABLE);
            }
        }
    }


ERTC应用
~~~~~~~~~~~

Tamper
^^^^^^^^^^^

.. code-block:: bash

    void ERTC_Config(void)
    {
        NVIC_InitType NVIC_InitStructure;
        EXTI_InitType  EXTI_InitStructure;

        /* Enable the PWR clock */
        RCC_APB1PeriphClockCmd(RCC_APB1PERIPH_PWR, ENABLE);

        /* Allow access to ERTC */
        PWR_BackupAccessCtrl(ENABLE);

        /* Reset BKP Domain */
        RCC_BackupResetCmd(ENABLE);
        RCC_BackupResetCmd(DISABLE);

        /* Enable the LSI OSC */
        RCC_LSICmd(ENABLE);

        /* Wait till LSI is ready */
        while(RCC_GetFlagStatus(RCC_FLAG_LSISTBL) == RESET)
        {
        }
        /* Select the ERTC Clock Source */
        RCC_ERTCCLKConfig(RCC_ERTCCLKSelection_LSI);

        /* Enable the ERTC Clock */
        RCC_ERTCCLKCmd(ENABLE);

        /* Deinitializes the ERTC registers */
        ERTC_Reset();

        /* Wait for ERTC APB registers synchronisation */
        ERTC_WaitForSynchro();

        /* Enable The external line21 interrupt */
        EXTI_ClearIntPendingBit(EXTI_Line19);
        EXTI_InitStructure.EXTI_Line = EXTI_Line19;
        EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
        EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
        EXTI_InitStructure.EXTI_LineEnable = ENABLE;
        EXTI_Init(&EXTI_InitStructure);

        /* Enable TAMPER IRQChannel */
        NVIC_InitStructure.NVIC_IRQChannel =  ERTC_IRQn;
        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
        NVIC_Init(&NVIC_InitStructure);

        /* Disable the Tamper 1 detection */
        ERTC_TamperCmd(ERTC_TAMP_1, DISABLE);

        /* Clear Tamper 1 pin Event(TAMP1F) pending flag */
        ERTC_ClearFlag(ERTC_FLAG_TP1F);

        /* Configure the Tamper 1 Trigger */
        ERTC_TamperTriggerConfig(ERTC_TAMP_1, ERTC_TamperTrig_FallingEdge);

        /* Enable the Tamper interrupt */
        ERTC_INTConfig(ERTC_INT_TAMP, ENABLE);

        /* Clear Tamper 1 pin interrupt pending bit */
        ERTC_ClearINTPendingBINT(ERTC_INT_TAMP1);

        /* Enable the Tamper 1 detection */
        ERTC_TamperCmd(ERTC_TAMP_1, ENABLE);
    }

    int main(void)
    {
        /* ERTC configuration */
        ERTC_Config();
        /* Write To ERTC Backup Data registers */
        WriteToERTC_BKP_DT(0xA53C);
        /* Check if the written data are correct */
        if(CheckERTC_BKP_DT(0xA53C) == 0)
        {
            /* Turn on LED2 */
        }
        while (1)
        {
        }
    }

    void ERTC_IRQHandler(void)
    {
        if(ERTC_GetFlagStatus(ERTC_FLAG_TP1F) != RESET)
        {
            /* Tamper 1 detection event occurred */
            /* Check if ERTC Backup Data registers are cleared */
            if(IsBackupRegReset() == 0)
            {
                /* OK, ERTC Backup Data registers are reset as expected */
            }
            /* Clear Tamper 1 pin Event pending flag */
            ERTC_ClearFlag(ERTC_FLAG_TP1F);

            /* Disable Tamper pin 1 */
            ERTC_TamperCmd(ERTC_TAMP_1, DISABLE);

            /* Enable Tamper pin */
            ERTC_TamperCmd(ERTC_TAMP_1, ENABLE);
        }
    }


Xin总结
--------------

.. contents::
    :local:

要点提示
~~~~~~~~~~~~~



问题整理
~~~~~~~~~~~~~




